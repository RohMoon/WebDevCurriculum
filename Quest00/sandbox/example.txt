https://git-scm.com/book/ko/v2

# 형상관리 시스템은 왜 나오게 되었을까요?
	- 형상관리란 개발과정에서의 시작과 끝의 과정중 변경되는 모든 사항을 관리하는 작업.
	- 대표적인 형상관리 시스템 git / svn 
	- 단순하게 본다면 변경사항을 체계적으로 관리 하는 것이다.
    @ 형상관리 구성요소  4가지 :
	- 형상 식별 (Configuration Identification)
		: 시스템의 효율적인 개발관리를 위해 형상항목(SCI)을 정의하고 분류 하는 활동 
	- 형상 통제 (Configuration Control)
		: 소프트웨어시스템의 각 베이스라인별로 형상을 설정하고 변경하는 일을 체계적인 절차(변경통제위원회 CCB)에 의해 통제하고 관리하여 결정하는 절차
	- 형상 감사 (Configuration Audit)
		: 형상 항목이 요구사항에 맞도록 잘 변경되었는지 확인 하는 것 FCA와 PCa가 있다. 
소스코드를 검토하는 FCA는 실제 성능이 기능 기준선 (Functional Basline) 및 할당 기주선 (Allocated Basline)에 명시된 요구조건을 충족하는가를 확인하는 절차
	- 형상 기록 (Configuration Status Accounting) 
		: 앞의 3가지 호라동을 자료로 수집하고 기록, 결과의 내용을 데이터베이스화 하고 원하는 형태로 다양하게 이용할수 있도록 하는 활동 .

위에 4가지 요소가 이렇다 정도이지, 결국에는 형상관리는 모든 변동 사항을 체크하는 것이고, 이것이 실수를 줄이기 위한 방법 중 완성도가 높다.

형상관리 말고도 PMS(프로젝트 관리시스템) 방법론과 돈이나 진척률 등 프로젝트의 전체적인 사항을 관리하는 시스템, ITSM (IT Service Management) ITIL(IT Infrastructure Library) 프레임워크를 토대로 서비스를 계획, 제공, 운영, 제어 하는 전체적인 활동 시스템, ALM(apllication LifeCycle Management)개발의 요구사항 분석에서부터 아키텍쳐, 변경 관리 등 끝까지 모든 과정을 관리 등 다른 것도 존재하는데 , 주제가 다를 뿐 본질적으론 비슷하다.



#형상 관리의 장점 
	- 소스코드의 변경이력을 관리 할 수 있어서 추적성이 좋다.
	- 배포가 편리하다.
	- 여러사람이 동일한 소스코드를 공유해 개발할 수 있으며,
	공유시에 발생하는 버전간의 충돌 문제등을 해결할 수 있다.
	- 장애 혹은 기능상 필요할 때 이전 버젼의 BaseLine으로 소프트웨	어를 되돌릴 수 있다. 

# 형상 관리 사용 이유 요약
	- 가시성의 결핍 : 소프트 웨어는 무형물
	- 통제의 어려움 : 가시성이 결핍된 상품의 제작은 통제가 어려움
	- 추적의 어려움 : 프로젝트의 중간 목표들을 연결 시키고 개발 과	정을 추적하기 어려움.
	- 감시의 미비 : 가시성과 추적성의 결핍은 프로젝트의 진행을 감시	하기 어렵게 함.
	- 무절제한 변경 : 통제되지 않고 관리 되지 않는 소프트웨어의 무	절제한 변경이 발생



#형상관리 시스템은 왜 나오게 되었을까요?
	
	- 가시성의 결핍 : 소프트 웨어는 무형물
	- 통제의 어려움 : 가시성이 결핍된 상품의 제작은 통제가 어려움
	- 추적의 어려움 : 프로젝트의 중간 목표들을 연결 시키고 개발 과	정을 추적하기 어려움.
	- 감시의 미비 : 가시성과 추적성의 결핍은 프로젝트의 진행을 감시	하기 어렵게 함.
	- 무절제한 변경 : 통제되지 않고 관리 되지 않는 소프트웨어의 무	절제한 변경이 발생



#git은 어떤 형상관리 시스템이고 어떤 특징을 가지고 있을까요? 분산형 형상관리 시스템이란 무엇일까요?

 - 깃은 소프트웨어를 개발하는 기업의 핵심 자산인 소스코드를 효과적으로 관리할 수 있게 도와주는 무료 공개 소프트웨어.
 - SVN 보다 여러 장점이 있어 SVN을 쓰던 개발 조직들은 하나둘씩 git으로 변경중.
- Git이 SVN과 다른 점은 분산형 관리 시스템이다.

- SVN  : 중앙 서버에 소스코드와 히스토리를 저장함.
- Git    : 소스코드를 여러 개발 PC와 저장소에 분산해서 저장
 그래서 중앙 서버에 장애가 발생해도 로컬 저장소에 커밋을 할 수 있으며, 로컬 저장소들을 이용하여 중앙 저장소의 복원도 가능하다.
 - 사본을 로컬에서 관리하기 때문에 Git이 Svn에 비해 훨씬 빠르다.
( SVN 의 경우 변경 로그 하나를 보는 것도 인터넷을 경유해야한다고 한다.)

- 깃의 장점 
      1. 소스코드를 주고 받을 필요 없이, 같은 파일을 여러명이서 동시에 작업하는 병렬 개발이 가능하다.
      2. 즉 브랜치를 통해 개발한 뒤, 본 프로그램에 합치는 방식으로 개발 진행이 가능하다. 
      3. 분산 관리이기 때문에 인터넷 연결이 되지않아도 개발을 진행할 수 있다. 중앙 저장소에 문제가 생겨도 원상복구가 가능하다.
      4.  팀 프로젝트가 아닌, 개인 프로젝트일지라도 GIT을 통해 버젼 관리를하면 체계적인 개발이 가능해지고 프로그램이나 패치를 배포하는 과정도 간단해집니다. (pull 을 통한 업데이트, patch 파일 배포)

 깃의 특징을 아래와 같이 공식 문서에서 말하고 있다. 

# Distributed development
	-전체 개발 이력을 각 개발자의 로컬로 복사본을 제공 하고 변경된 이력을 다시 하나의 저장소로 복사한다.
	- 이러한 변경은 추가개발지점을 가져와, 로컬 개발 지점과 동일하게 병합 할 수 있다. 저장소는 Git protocol 및 Http로 쉽고 효율적 (특별한 웹서버 구성없이) 으로 접근 할 수 있다.

# Strong support for non-linear development
	- 신속하고 편리한 Branch 및 merge 지원, 비선형 개발 이력을 시각화하고 탐색할 수 잇는 강력한 도구를 제공.

# Efficient handling of large projects
	-Git은 매우 빠르고, 대형 프로젝트나 이력이 많은 작업에 매우 합리적이다. Git은 대ㅜ분의 다른 버젼 관리 시스템보다 빠르게 요청한다. 그리고 일부 작업에서는 더 빠륵 ㅔ진행한다.
	-또한, 최근의 정상급 오픈소스 버젼관리 시스템보다 장기간의 수정내역을 매우 효율적인 압축방법을 사용한다.

# Cryptograhpic authentication of history
	- Git의 이력은 성공한 개발 이력의 commit에 의해 개정명으로 저장된다. 일단 그것이 배포되면, 그것을 모르고 예전 버져으로 변경하는 것은 불가능하다. 그리고 그것들을 암호화 할 수 있다.

# Toolkit Design,
	- Unix의 전통에 따라, Git은 C로 작성된 많은 소규모 도구 모음이다. 그리고 많은 스크립트들이 기능 보강을 제공한다.
Git 은 새로운 기발한 작업을 위한 손쉬운 사용과 쉬운 스크립팅을 위한 도구를 제공한다.	

#4.3 Git GUI

 - 너무 많은 git 명령어를 자유자재로 외울 자신이 없을 땐 GUI를 사용할 수도 있다.

#git은 어떻게 개발되게 되었을까요? git이 분산형 시스템을 채택한 이유는 무엇일까요?

#git과 GitHub은 어떻게 다를까요?
	-Git은 형상 관리 도구(버전 관리 시스템)
	-GitHub는 형상 관리 도구 (버전 관리) 웹호스팅 서비스
     Git : 
	프로젝트를 진행하면서 소스코드나 USB나 메일로 주고 받는건 엄청난 낭비임과 동시에 보안성 위험이 있다.
	그렇기 때문에 프로젝트를 진행 함에 있어 형상관리 도구를 사용한다.
	형상관리 도구를 사용하면 변경을 쉽게 되돌릴 수 있다.
	소스코드를 과거의 특정 시점으로 되돌리거나, 특정시점의 변경 사항을 취소하거나, 두 버젼의 소스 코드를 비교하는 등의 일이 가능하다.

     GitHub :
	협업하고 있는 코드를 저장할 서버가 필요하다.
	버전 관리 시스템을 지원하는 웹호스팅 서비스의 기능을 통해, push ,pull Request같은 이벤트에 반응하여 자동으로 작업(배포 등)을 실행 할수 있다. 

#git의 clone/add/commit/push/pull/branch/stash 명령은 무엇이며 어떨 때 이용하나요? 그리고 어떻게 사용하나요?
	clone : 원격 Git 저장소 복제 / 로컬로 복제
	- 원격 Git  저장소의 주소Https혹은 SSH코드를 확인하고,
	git clone [Repo_URL OR SSH] [DIR]로 사용 가능하다.
	Dir 을 생략하면 현재 위치로 복제할 위치를 지정한다.
	(이후 git remote-v로 현재 리모트 확인 가능함.)
	
	add : 작업 디렉토리 상의 변경 내용을 스테이징 영역에 추가하기 위해 사용한다.
	위에서 말한것처럼	Commit 이전에 변경분을 모아두기 위한명령어		이고 commit이 되기전에는 변경이력에 영향을 주지않는다.
	git add <파일/디렉토리 경로>로 사용하면 
	     작업 디렉토리의 변경 내용의 일부만 스테이징 영역에 넘기고 	싶을때는 수정한 파일이나 디렉토리의 경로를ㄹ 인자로 넘긴다.

	git add . 으로 사용하면
	     현재 디렉토리의 모든 변경 내용을 스테이징 영역으로 넘기고 	싶을때는 . 을 인자로 준다.
	
	git add -A는
	     작업 디렉토리 내의 모든 변경 사항을 몽땅 스텡지ㅣㅇ 영역으로 넘기게 된다. 작업 디렉토리 상에 어디에 위치하든 동일하게 모든 내용을 스테이징으로 넘긴다. git add . 의 경우에는 실행된 디렉토리 이하에서만 내용을 포함하게 되며 해당 디렉토리 기준으로 상위 디렉토리의 변경은 포함하지 않는다. 만약에 git add . 를 프로젝트 최상위 디렉토리에서 실행한다고 하면 git add -A 와 동일한 효과를 내게 된다.

	git add -p의 경우네는 각 변경 사항을 터미널에서 직접 눈으로 하나씩 확인하면서 스테이징 영역으로 넘기거나 제외시킬수가 있다. 변경내용이 많을 때에 변경 기록으로 나누어서 남기고 싶을 때 유용하게 사용할 수 있다.

	commit : 파일 및 폴더의 추가/ 변경 사항들에 대한 기록을 한다.
	add 로 스테이징 영역(인덱싱되어있는) 에 들어있던 내용들을 시간 순으로 저장하며 최근 커밋부터 거슬러 올라가면 과거 변경 이력과 내용을 확인 할 수 있다. commit 을 하게 되면 해당 기록에 대한 이름으로 영문/숫자40자리로 이루어진 이름이 부여되어 이것을 id값으로 구분할 수 있다.

	git commit 옵션으로는 -m -am 등이 있다. 
	
	git commit -m 'message' 를 사용하면 commit에서 vim을 들어가 msg를 작성하는 작업을 skip하고 명령창에서msg를 바로 작성할수 있다.
	
	git commit am 'message' 는 커밋이 된 이후에 다시 새버젼을 만들 경우 'add', 'vim에서 msg 작성하는 작업'을 명령창에서 바로 할 수 있다.

	push 명령어는 origin 즉, 원격 저장소의 브랜치에 밀어올린다, 기록한다. 따라서 push를 할때에는 원하는 브랜치를 명시하고, 올리면 해당 브랜치에 기록할 수 있다. 
	git branch -M main
	git push origin main <<
	기본적으로는 git push <저장소명> <브랜치명> 으로 사용한다.
	ex )  git push origin my-feature 
	git clone을 통해 저장소를 복제했다면 일반적으로 origin이며 git remote 명령어를 통해서 정확한 저장소명을 알아낼 수도 있다.
	git remote
	origin   <<
	또한 git push를 날릴때마다 매번 저장소명과 브랜치명을 명시하는게 귀찮다면 -u 옵션을 사용하여서 최초 저장소명과 브랜치명만 입력하여 이후에 모든 추가 입력사항을 생략할 수 있다고 한다.
	
	예를 들어, 다음과 같이 저장소명과 브랜치명을 남기면서 -u옵션과 함께  git push명령어를 날리면
	git push -u origin my-feature
	그 이후에 커밋한 코드 변경분을 원격 저장소에 올릴 때는 인자없이 git push만 입력해주면 된다.

	혹은 여러 브랜치를 변경하면서 작업을 하는 경우라면, 최초에 한번 인자를 넘기는 것도 힘들게 느껴질 수 있는데, 대부분의 경우에는 로컬저장소와 원격 저장소에서 동일한 브랜치 이름을 사용하기 때문에  항상현재 브랜치를 기준으로 git push 명령어가 작동한다면 매우 편리하다고한다.
이를 위해서는 약간의 설정이 필요하다.
 push.default 설정을  current로 설정해준다.
 git cofing --global push.default current  
이렇게 설정을 해두면 어느 브랜치에서 작업을 하든 git push 만 날리면 원격 저장소에 동일한 브랜치로 코드 변경분이 업로드된다.
	
	git pull을 사용하면 원격저장소의 변경된 데이터를 가져올 수 있다.
	pull한 데이터가 어떻게 반영되는지는 아래 간단한 문자도식을 ㅗ확인 해보자면  
	A -> B -> X-> Y(origin/master)

	A -> B(master)
	인 상황에서 원격 저장소의 커밋Y를 로컬로 가져오는 경우를 본다.
	이 상황은 단순히 'fatst-forward 병합' 이 이루어진다.
	이 내부의 'master'는 로컬 저장소의 'master' 브랜치, 'origin/master'는 원격 저장소 'origin'의 'master' 브랜치를 나타낸다.

	A-> B-> X-> Y(origin/master master)
그러나 로컬 저장서의 'master 브랜치에서도 변경 사항이 생긴 경우, 양쪽의 변경을 통합할 필요가 있다.

	A->B->X->Y (origin /master)
	          |    |  
	A->B->C->D  (master)
이때 pull을 실행하여 소스를 병합할수 있다.  충돌하는 변경사항이 없을 경우 자동적으로병합 커밋이 만들어지지만, 충돌이 있을 경우에는 충돌난 부분을 수동으로 해결한 다음 직접 commit을 해야한다.
	
	branch의 명령어의 경우
	git branch 현재는 master 브랜치만 존재한다. (master : 최초 레포지토리 생성 후 커밋하면 자동으로 생기는 브랜치) 
	*가 붙어있는 브랜치가 현재활성화된 브랜치이다.

	git branch -v 를 사용하면 브랜치의 마지막 커밋 메세지를 확인 할 수 있다. 
	git branch <브랜치명> 을 사용해서 브랜치를 생성할 수 있다.
	git checkout <브랜치명>으로 브랜치를 이동 할 수 있다.
	git checkout -b <브랜치명> 은 브랜치를 생성하고 바로 이동할 수 있다.
	git branch -d <브랜치명>로 브랜치를 삭제할 수 있다.


	stash 는 임시저장과 비슷한 맥락이다.
	예를 들어서 내가 어떤 작업을 하고 있다가 다른 요청이 들어와 잠시 작업을 멈추고 브랜치를 변경해야한다고 하는 상황에서 내가 마무리하지 않은 작업에 대해서 commit하는 것이 껄끄러운 경우가 충분히 있을 수 있다.   (  
		Stashed Changes
		         |
		Workign Directory  - stage-> Staged Snapshot - commit -> committed SnapShots
		)
	아직 마무리되지 않은 작업을 잠시 스택에 저장할 수 있도록 하는 명령어이다.
	이를 commit하지 않고 나중에 다시 꺼내와서 마무리할 수 있도록 해준다.

	- git stash 명령을 사용하면 워킹 디렉토리에서 수정한 파일들만 저장한다.
	- stash  란 아래에 해당하는 파일들을 보관해두는 장소이다.
		1. modified 이면서 Tracked 상태인 파일 
			- Tracked 상태인 파일을 수정한 경우
			- Tracked : 과거에 이미 commit 하여 스냅샨에 넣어진 관리 대상의 파일
		2. Staging Area 에 있는 파일 (Staged 상태의 파일)
			- git add 명령을 실행한 경우
			- Staged 상태로 만들려면 git add명령을 실행해야 한다.
	git Stash 명령어를 통해 stash를 스택에 만들어 하던 작업을 임시로 저장한다.
		- 예를 들어서 파일2개를 수정하고 그 중하나는 Staging Area에 추가한다. 아직 작업 중인 2개의 파일은 commit 할게 아니기 때문에 모두 stash에 넣는다.
			1. index.html: Staging Area에 있는 파일 (Staged 상태의 파일)
			2. lib/simplegit.rb:Modifed 이면서 Tracked 상태인 파일


	Ex) // working directory에 있는 파일의 상태 확인
	$ git status
	Changes to be committed:
	(use "git reset HEAD <file>..." to unstage)
	modified:   index.html
	Changes not staged for commit:
	(use "git add <file>..." to update what will be committed)
	(use "git checkout -- <file>..." to discard changes in working directory)
	modified:   lib/simplegit.rb
	
	git Stash / git Stash save 명령어로 스택에 새로운 stash가 만들어진다.
	이 과정을 통해서 Working directory는 깨끗해진다.
	
	git stash list를 통해서 stash에 넣은 목록을 확인 할 수 있다.
	git stash apply 를 통해서 작업을 다시 가져올 수 있다.
	ex) //가장 최근의 stash를 가져와 적용시킨다.
	git stash apply 
	//  stash 이름 (ex. stash@{2})에 해당 하는 stash를 적용한다.
	git stash apply [stash 이름]
	 위 명령어로는 Staged 상태였던 파일을 자동으로 다시 Staged 상태로 만들어주지 않는다.
	-index 옵션을 주어야 Staged 상태까지 복원한다. 이를 통해 원래 작업하던 파일의 상태로 돌아올 수 있다.
	//Staged 상태까지 저장
	git stash appyl --index

	stash  제거하기 
	git stash drop
	apply 옵션은 단순히 stash를 적용하는 것으로, 해당 stash는 스택에 여전히 남아있다.
	스탹에 남아 있는 stash 는 위의 명령어를 사용하여 제거할 수 있다.

	//가장 최근의 stash를 제거한다.
	git stash drop
	//stash 이름(ex. stash@{2})에 해당하는 stash를 제거한다.
	git stash drop [stash 이름]
	
	만약 저장되어 있던 stash를 가져와 적용과 동시에 해당 stash를 제거하고 싶으면
	git stash pop 명령을 사용하면 된다.
	// apply + drop의 형태	
	git stash pop

	실수로 잘못 stash를 가져와 적용했다면 
	git stash show -p | git apply -R을 사용한다.
	// 가장 최근의 stash를 사용하여 패치를 만들고 그것을  거꾸로 적용한다.
	git stash show -p | git apply -R
	//stash 이름 (ex. stash@{2}) 에 해당하는 stash 를 이용하여 거꾸로 적용한다.
	git stash show -p [stash 이름]  | git apply -R
	
	Alias를 사용할 수도 있다.
	stash-unapply 명령어로 간단하게 사용할 수 있다.
	git config --global alias.stash-unapply '! git stash show -p | git apply -R'
	git stash apply
	#... work work work
	//  alias로 등록한 stash 되돌리기 명령어
	git stash upapply


#git의 Object, Commit, Head, Branch, Tag는 어떤 개념일까요? git 시스템은 프로젝트의 히스토리를 어떻게 저장할까요?

#리모트 git 저장소에 원하지 않는 파일이 올라갔을 때 이를 되돌리려면 어떻게 해야 할까요?

    @깃 스테이지 에리어
	git add 명령어를 사용하면 스테이징 에리어로 들어가게 된다고 한다.  이 부분은 SVN같은 기존의 버전관리 시스템에서는 없던 개념이기 때문에 Git으로 처음 넘어온 분들이 헷갈려하는 부분이기도 하다.
	스테이징 영역은 작업 디레토리와 Git 저장소의 변경 이력 사이에 징검다리 같은 역할을 하고, 작업 디렉토리는 아직 커밋할 준비가 안된 변경 내용을 자유롭게 수정할 수 있는 공간인 반면에, 스테이징 영역은 커밋할 준비가 된 변경 내용이 Git 저장소에 기록되기 전에 대기하는 장소라고 생각할 수 있다. git add 명령어를 사용하면 현재 작업 디렉토리에 있는 모든 또는 일부 변경내용을 스테이징 영역으로 이동시킬 수 있다.
git commit 명령어가 변경 이력을 남길 시점에는 작업 디렉토리에 있는 변경 내용은 고려하지 않고, 스테이징 영역에 넘어온 변경 내용만 사용되기 때문에 이 두개의 공간을 서로 헷갈려하면 안된다.

이렇게 작업 디렉토리와 스테이징을 구분하면 변경 이력을 남길때 작업 디렉토리에 있는 변경 내용을 한번에 몽땅 기록않고, 조금씩 나누어서  기록할수 있다는 장점이 있다고 한다. 이를 통해서 각 변경 기록에 논리적으로 하나의 변경 사항을 담기가 용이한데 이렇게 하면 나중에 버그를 추적하거나 변경 이력을 롤백 할때도 이점이 있다.



